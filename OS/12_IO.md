[TOC]

# Hardware

## I/O Hardware

* Common concepts: signals from I/O devices interface with computer
    * **bus**: an interconnection between components (including CPU)
    * **port**: connection point for device
    * **controller**: component that control the device
        * can be integrated to device or separate circuit board
        * usually contains processor, microcode, private memory, bus controller, etc
* I/O access can use polling or interrupt



**IO Instructions**

* Some CPU architecture has dedicated I/O instructions
    * e.g., x86: in, out, ins, outs
    * æ—©æœŸIOè®¾å¤‡è¾ƒç®€å•ï¼Œå¯ä»¥ç›´æ¥å¾€æŒ‡å®šç«¯å£å·å†™æ•°æ®
* Devices usually provide registers for data and control I/O of device
    * device driver places (pointers to) commands and data to register
    * registers include data-in/data-out, status, control (or command) register
    * typically 1-4 bytes, or FIFO buffer



Devices are assigned addresses for registers or ondevice memory

* direct I/O instructions
    * to access (mostly) registers
* memory-mapped I/O
    * <u>data and command registers mapped to processor address space</u>
    * to access (large) on-device memory (graphics)

## Polling

* For each I/O operation:
    1. busy-wait if device is busy (status register)
    2. send the command to the device controller (command register)
    3. read status register until it indicates command has been executed
    4. read execution status, and possibly reset device status
* <u>Polling requires busy wait</u>
    * <u>reasonable if device is fast; inefficient if device slow</u>ï¼šçœ‹è®¡ç»„çš„ä¾‹é¢˜ï¼Œæ•°æ®é‡è¶Šå°è¶Šå¿«ï¼Œè¶Šé€‚åˆè½®è¯¢

## Interrupt

* Polling requires **busy-wait**, inefficient use of CPU resource
* Interrupts can avoid busy-wait
    1. device driver send a command to the controller, and returnï¼ˆä¸éœ€è¦wait
    2. OS can schedule other activities
    3. device will interrupt the processor when command has been executed
    4. OS retrieves the result by handling the interrupt
* Interrupt-based I/O requires context switch at start and end
    * if interrupt frequency is extremely high, context switch wastes CPU time
    * solution: use polling instead
        * example: NAPI in Linux enables polling under very high network load

```mermaid
graph TB

subgraph CPU
    a["device driver initiates I/O"]
    d["CPU receiving interrupt,<br />transfers control to<br />interrupt handler"]
    e["interrupr handler<br />proces data,<br />returns from interrupt"]
    f["CPU resumes<br />processing of<br />interrupted task"]
end
subgraph "I/O controller"
    b[initiates I/O]
    c["input ready, output<br /> complete, or error<br />generates interrupt signal"]
end
a-->b-->c-->d-->e-->f
a-.CPU executing checks for<br />interrupts between instructions..->d
```

* Interrupt is also used for exceptions
    * <u>protection error for access violation</u>
    * <u>page fault for memory access error</u>
    * <u>software interrupt for system calls</u>
* Multi-CPU systems can process interrupts concurrently
    * sometimes a CPU may be dedicated to handle interrupts
    * interrupts can also have CPU affinity
        * å¦‚æœåªåœ¨ä¸€ä¸ªcoreä¸Šå¤„ç†ä¸­æ–­ï¼Œåˆ™å¯èƒ½å¯ä»¥æé«˜cacheå‘½ä¸­ç‡

### ~~Interrupt Handler~~

#### ~~â€» Linux Interrupt Handler~~

* **Top-halves** (interrupt handlers) must <u>run as quickly as possible</u>
    * They are interrupting other kernel/user code
    * They are often timing-critical because they deal with hardware.
    * They run in interrupt context: they cannot block
        * å› ä¸ºæ²¡æœ‰è‡ªå·±çš„contextï¼Œæ‰€ä»¥ä¸èƒ½å†è¢«ä¸­æ–­
    * One or all interrupt lines are disabled
* Defer the less critical part of interrupt processing to a **bottom-half**
    * ä¸‹åŠæ®µäºåå°æ‰§è¡Œï¼Œå¯ä»¥æœ‰æ–°çš„ä¸­æ–­å‘ç”Ÿ



**Top Half**

* æœ€â¼©çš„åŒ–å…¬å…±ä¾‹ç¨‹
* ä¿å­˜å¯„å­˜å™¨ã€å±è”½ä¸­æ–­ â€“ æ¢å¤å¯„å­˜å™¨ï¼Œè¿”å›ç°åœº
* æœ€é‡è¦:è°ƒâ½¤åˆé€‚çš„ç”±ç¡¬ä»¶é©±åŠ¨æä¾›çš„ä¸­æ–­å¤„ç†handler
* å› ä¸ºä¸­æ–­è¢«å±è”½ï¼Œæ‰€ä»¥ä¸è¦åšå¤ªå¤šäº‹æƒ…(æ—¶é—´ã€ç©ºé—´)
* å°†è¯·æ±‚æ”¾â¼Šé˜Ÿåˆ—(æˆ–è®¾ç½®flag)ï¼Œå°†å…¶ä»–å¤„ç†æ¨è¿Ÿåˆ° bottom half å†…

**Bottom Half**ï¼šå»¶è¿Ÿå®Œæˆ

* æä¾›å¯ä»¥æ¨è¿Ÿå®Œæˆä»»åŠ¡çš„æœºåˆ¶
    * softirqs
    * tasklets (å»ºâ½´åœ¨softirqsä¹‹ä¸Š)
    * work queue
    * å†…æ ¸çº¿ç¨‹
* <u>è¿™äº›æœºåˆ¶éƒ½å¯ä»¥è¢«ä¸­æ–­</u>



**Softirqs** (è½¯ä¸­æ–­)

é™æ€åˆ†é…ï¼šåœ¨å†…æ ¸ç¼–è¯‘æ—¶å°±ç¡®å®š

* ç‰¹ç‚¹
    * æ‰§è¡Œæ—¶é—´ç‚¹
        1. ä¸­æ–­ï¼ˆtop halfï¼‰ä¹‹å
        2. syscallæˆ–å¼‚å¸¸ä¹‹å
        3. è°ƒåº¦å™¨æ˜¾ç¤ºæ‰§è¡Œksoftirqd
    * å¹¶å‘
        1. å¯ä»¥å¤šæ ¸
        2. å¿…é¡»æ˜¯å¯é‡å…¥çš„ï¼ˆï¼Ÿï¼Ÿ
        3. å¯æ ¹æ®éœ€è¦æ·é”
    * å¯ä¸­æ–­ï¼š<u>softirqè¿è¡Œæ—¶å¯å†è¢«ä¸­æ–­æŠ¢å </u>
* Softirq Rescheduling
    * softirqè¦æ±‚èƒ½è¢«é‡è°ƒåº¦ï¼Œå³å†å¤„ç†è½¯ä¸­æ–­Aæ—¶ï¼Œèƒ½æŒ‚èµ·Aåˆ‡æ¢è‡³è½¯ä¸­æ–­B
    * å¤„ç†æ–¹å¼
        1. ç­‰Aå®Œï¼šBå€å»¶è¿Ÿå“åº”
        2. æ€»æ˜¯é©¬ä¸Šå¤„ç†Bï¼šå¯èƒ½ä¼šæœ‰starvationï¼ˆå¯¹äºAæ¥è¯´ï¼‰
        3. è§£å†³æ–¹å¼ï¼šé…é¢ï¼ˆquotaï¼‰ï¼Œè°ƒåº¦å™¨æ¯æ¬¡åªè¿è¡Œæœ‰é™æ•°é‡çš„è¯·æ±‚



**Tasklet**

* ä¼˜ç‚¹
    * å¯åŠ¨æ€åˆ†é…ï¼Œæ•°é‡ä¸é™
    * ç›´æ¥è¿è¡Œå†è°ƒåº¦å®ƒçš„CPUä¸Šï¼ˆcache affinityï¼‰
    * æ‰§è¡ŒæœŸé—´ä¸èƒ½è¢«å…¶ä»–çš„bottom-halfæŠ¢å 
        * ä¸å­˜åœ¨å†å…¥çš„é—®é¢˜
        * æ— éœ€é”
* ç¼ºç‚¹
    * å’Œsoftirqä¸€æ ·æ²¡æœ‰ä¸Šä¸‹æ–‡ï¼Œæ— æ³•ç¡çœ 



**Work Queues**

* ä¸åŒäºä½¿ç”¨ä¸­æ–­ä¸Šä¸‹æ–‡çš„softirqå’Œtaskletï¼Œwork queueä½¿ç”¨çš„æ—¶è¿›ç¨‹ä¸Šä¸‹æ–‡ï¼Œå› æ­¤å¯ä»¥ç¡çœ 
* æ–¹å¼
    * åœ¨å†…æ ¸ç©ºé—´ç»´æŠ¤FIFOé˜Ÿåˆ—ï¼Œwork queueå†…æ ¸è¿›ç¨‹ä¸æ–­pollingé˜Ÿåˆ—
    * ä¸­æ–­è´Ÿè´£`enqueue(fn, args)`ï¼Œwork queueè´Ÿè´£dequeueå¹¶æ‰§è¡Œ`fn(args)`
* ç‰¹ç‚¹
    * åªåœ¨å†…æ ¸ç©ºé—´ï¼Œä¸å’Œä»»ä½•ç”¨æˆ·è¿›ç¨‹å…³è”ï¼Œæ²¡æœ‰è·¨æ¨¡å¼åˆ‡æ¢å’Œæ•°æ®æ‹·è´

## ==DMA==

åœ¨CPUä¸å‚ä¸çš„æƒ…å†µä¸‹åœ¨è®¾å¤‡ä¹‹é—´è¿›è¡Œæ•°æ®çš„æ¬è¿

* DMA transfer data directly between I/O device and memory
    * OS only need to issue commands, data transfers bypass the CPU
    * no programmed I/O (one byte at a time), data transferred in large blocks
    * it requires DMA controller in the device or system
* OS issues commands to the DMA controller
    * a command includes: operation, memory address for data, count of bytesâ€¦
    * usually it is the pointer of the command written into the command register
    * when done, device interrupts CPU to signal completion



**Six Steps of DMA TransferğŸ‘‡**

![](assets/image-20201228152247492.png)

# Application I/O Interface

* I/O system calls encapsulate device behaviors in generic classes
    * in Linux, devices can <u>**be accessed as files**</u>
        * `/dev/`
    * low-level access with ioctl
* Device-driver layer hides differences among I/O controllers from kernel
    * each OS has its own I/O subsystem and device driver frameworks
    * new devices talking already-implemented protocols need no extra work

## Characteristics of I/O Devices

==Devices vary in many dimensions==

* character-stream or block
* sequential or random-access
* synchronous or asynchronous (or both)
* sharable or dedicated
* speed of operation
* read-write, read only, or write only



Broadly, I/O devices can be grouped by the OS into

* block I/O: read, write, seek
* character I/O (Stream)
* memory-mapped file access
* network sockets



~~**Synchronous/Asynchronous I/O**~~

* Synchronous I/O includes blocking and non-blocking I/O
    * blocking I/O: process suspended until I/O completed
        * easy to use and understand, but may be less efficient
        * insufficient for some needs
    * non-blocking I/O: I/O calls return <u>as much data as available</u>
        * process does not block, returns whatever existing data (read or write)
        * <u>use **select** to find if data is ready</u>, then use **read** or **write** to transfer data (blocking during this process); å¦‚æœæ²¡æœ‰å°±å†non-blockingåœ°IO
* Asynchronous I/O: process runs while I/O executes,
    * I/O subsystem signals process when I/O completed <u>via signal or callback</u>ï¼ˆä¸éœ€è¦é€šè¿‡selectæ¥åˆ¤æ–­æ˜¯å¦å·²ç»IOå¥½äº†ï¼‰ - <u>data is already in the buffer, no need to use read() to get the data</u>
    * difficult to use but very efficient



**Block and Character Devices**

* **Block** devices access data in blocks, such as <u>disk drives</u>â€¦
    * commands include `read, write, seek`
    * raw I/O, direct I/O, or file-system access
    * memory-mapped file access possible (e.g., memorymapped files)
    * DMA
* **Character** devices include <u>keyboards, mice, serial ports</u>â€¦
    * very diverse types of devices
    * e.g., /dev/ttyS0



# Kernel I/O Subsystem

## I/O scheduling

* to queue I/O requests via per-device queue
* to schedule I/O for fairness and quality of service



## Buf/Cache

ç¼“å†²å’Œç¼“å­˜çš„åŒºåˆ«

* Buffering - store data in memory while transferring between devices
    * to cope with device <u>speed mismatch</u>: receive from network and write to ssd, double buffering
    * to cope with device transfer size mismatch: network buffer reassembly of message
    * to maintain â€œcopy semanticsâ€: write()
        * éœ€è¦æŠŠæ•°æ®ä»ç”¨æˆ·ç¼“å†²åŒºæ‹·è´åˆ°å†…æ ¸ç¼“å†²åŒº
* Caching: hold a copy of data <u>for fast access</u>
    * key to performance
    * sometimes combined with buffering
        * Buffer in memory is also used as caching for file operations

## Spooling/DevRes

* Spooling(å‡è„±æœº): <u>hold **output**</u> if device can serve only one request at a time
    * i.e., printingï¼Œæ¯æ¬¡åªèƒ½æ‰“ä¸€å¼ çº¸ï¼Œè‹¥æœ‰å¤šä¸ªæ‰“å°ä»»åŠ¡åˆ™éœ€è¦æ’é˜Ÿï¼Ÿï¼Ÿ
* Device reservation: provides <u>exclusive access</u> to a device
    * system calls for allocation and de-allocation
    * watch out for deadlock

## Error Handling

* Some OSes try to recover from errors
    * e.g., device unavailable, transient write failures
    * sometimes via retrying the read or write
    * some systems have more advanced error handling
        * track error frequencies, stop using device with high error frequency
* Some OSes just return an error number or code when I/O request fails
    * system error logs hold problem reports

## ==I/O Prot==

* OS need to protect I/O devices
    * e.g., keystrokes can be stolen by a keylogger if keyboard is not protected é˜²æ­¢æµè§ˆå™¨èƒ½è·å–é”®ç›˜ä¿¡æ¯ç„¶åè·å¾—å¯†ç ç­‰ç­‰
    * always assume user may attempt to obtain illegal I/O access
* To protect I/O devices:
    * define all I/O instructions to be privileged
        * <u>I/O must be performed via system calls</u>ï¼Œåœ¨å†…æ ¸ä¸­è¿›è¡Œ
    * memory-mapped I/O and I/O ports must be protected too

## Kernel DSï¼ˆä¸è€ƒï¼‰

* Kernel keeps state info for I/O components
    * e.g., open file tables, network connections, character device state
    * many data structures to track buffers, memory allocation, â€œdirtyâ€ blocks
        * sometimes very complicated
* Some OS uses message passing to implement I/O, e.g., Windows
    * message with I/O information passed from user mode into kernel
    * message modified as it flows through to device driver and back to process

# I/O Req to HW Opï¼ˆä¸è€ƒï¼‰

![image-20210104144631565](assets/image-20210104144631565.png)

## Performance ï¼ˆè€ƒï¼‰

å½±å“å› ç´ 

* CPU to execute device driver, kernel I/O codeï¼ˆæ­¤æ—¶æ‰§è¡Œçš„ä»£ç å¯¹ç”¨æˆ·æ€è¿›ç¨‹å¹¶æ²¡æœ‰å®é™…çš„å¸®åŠ©ï¼‰
* context switches due to interrupts
* data buffering and copying
    * network traffic especially stressful



æ”¹è¿›æ–¹æ³•

* Reduce number of context switchesï¼ˆå¤šåƒå°‘æ¬¡ï¼‰
* Reduce data copying
* Reduce interrupts by using large transfers, smart controllers, polling
* Use DMA
* Use smarter hardware devicesï¼ˆoffloadingï¼Œç¡¬ä»¶è®¡ç®—ï¼‰
* Balance CPU, memory, bus, and I/O performance for highest throughput
* Move user-mode processes / daemons to kernel threads