[TOC]

# Basis

## Hardware Addr Protection

* CPU must check every memory access generated in user mode to be sure it is between base and limit for that user
* the instructions to loading the base and limit registers are privileged

<img src="assets/image-20201112092440846.png" style="zoom:50%;" />

## Address Binding

Addr are represented in different ways at different stages

* **source code** addresses are usually <u>symbolic</u> (e.g., temp)
* **compiler** binds symbols to <u>relocatable addresses</u>
    * e.g., â€œ14 bytes from beginning of this moduleâ€ (åç§»é‡)
* **linker** (or loader) binds relocatable addresses to <u>absolute addresses</u>
    * e.g., 0x0e74014
* Each binding maps one address space to another



Binding of I&D to Mem happens in 3 stages

* **Compile time**: If memory location known(åœ¨ç¼–è¯‘æ—¶å°±çŸ¥é“äº†è¿›ç¨‹åœ¨å†…å­˜ä¸­çš„é©»ç•™åœ°å€), <u>absolute code</u> can be generated; must recompile code if starting location changes
* **Load time**: Must generate <u>relocatable code</u> if memory location is not known at compile time
* **Execution time**: Binding delayed until run time if the process can be moved during its execution from one memory segment to another (åœ¨æ‰§è¡Œæ—¶ä»ä¸€ä¸ªå†…å­˜æ®µè½¬ç§»åˆ°å¦ä¸€ä¸ªå†…å­˜æ®µ)
    * Need hardware support for address maps (e.g., base and limit registers)

## Logi & Phy Addr

### MMU

* Consider simple scheme. which is a generalization of the base register scheme.
* The base register now called **relocation register**
* The value in the relocation register is <u>added</u> to every address generated by a user process at the time it is sent to memory
    * <img src="assets/image-20201123161625888.png" style="zoom: 25%;" />
* The user program deals with logical addresses; it never sees the real physical addresses
    * Execution-time binding occurs when reference is made to location
        in memory
    * Logical address bound to physical addresses

## Dynamic Loading

* The entire program does need to be in memory to execute. Routine is not loaded until it is called
* All routines kept on disk in <u>relocatable load format</u>
* Advantage
    * Better memory-space utilization; unused routine is never loaded
    * Routine is loaded only when it is needed -> Useful when large amounts of code are needed to handle infrequently occurring cases
* No special support from the operating system is required
    * Implemented through program design
    * OS can help by providing libraries to implement dynamic loading

## Dynamic Linking

* Static linking â€“ system libraries and program code combined by the loader into the binary program image
* Dynamic linking â€“linking postponed until execution time
    * Small piece of <u>code</u>, **stub**, used to locate the appropriate memory-resident library routine
        * stubä»ç„¶æ˜¯ä»£ç ï¼Œç”¨ä»¥æŒ‡å‡ºå¦‚ä½•å®šä½é€‚å½“çš„å†…å­˜é©»ç•™åº“ç¨‹åºï¼Œæˆ–è€…è¯¥ç¨‹åºä¸åœ¨å†…å­˜æ—¶å¦‚ä½•è£…å…¥åº“
        * ä¸éœ€è¦åŠ è½½æ•´ä¸ªåº“ï¼Œåªéœ€è¦ç”¨stub+PLTå®šä½å³å¯
    * Stub replaces itself with the address of the routine, and executes the routine
* Dynamic linking is particularly useful for:
    * shared libraries
    * patching system libraries
        * Versioning may be needed
        * å¦‚æœä¸ç”¨åŠ¨æ€é“¾æ¥ï¼Œåˆ™å¿…é¡»å…¨éƒ¨é‡æ–°é“¾æ¥ä¸€é
* Help from OS: share libraries between processes

# Contiguous Allocation

## Protection

é‡‡ç”¨[é‡å®šä½å¯„å­˜å™¨+ç•Œé™åœ°å€å¯„å­˜å™¨](# Hardware Addr Protection)çš„æ–¹æ³•:

<img src="assets/image-20201112092440846.png" style="zoom:50%;" />

## Memory Allocation: Variable Partition

Variable Partitionï¼šå¯å˜åˆ†åŒºæ–¹æ¡ˆ

* Multiple-partition allocation
* Degree of multiprogramming limited by number of partitions
* Variable-partition sizes for efficiency (sized to a given processâ€™ needs)
* Hole â€“ block of available memory(ä¸€æ•´å—å¯ç”¨å†…å­˜); holes of various size are scattered throughout memory
    * ä¸€å¼€å§‹ï¼Œæ‰€æœ‰å†…å­˜éƒ½å¯ç”¨ï¼Œå› æ­¤æœ‰ä¸€å¤§ä¸ªå­”ï¼Œåˆ°åæ¥ï¼Œå­”å°±å˜å¾—å°è€Œåˆ†æ•£
* Steps:
    * When a process arrives, it is allocated memory from a hole large enough to accommodate it
    * Process exiting frees its partition, adjacent free partitions combined
* Operating system <u>maintains information</u> about:
    * allocated partitions
    * free partitions (hole)



**Allocation Algorithm**

* **first-fit**: allocate from the first block that is big enough
* **best-fit**: <u>allocate from the smallest block that is big enough</u>
    * must search entire list, unless ordered by size
    * produces the smallest leftover hole
* **worst-fit**: allocate from the largest hole
    * must also search entire list
    * produces the largest leftover hole
* ä¸‰ç§æ–¹æ³•ç°åœ¨ä¸é‡è¦äº†
* ç¢ç‰‡åŒ–å¯¹äºä¸‰ä¸ªç®—æ³•æ¥è¯´éƒ½æ˜¯å¤§é—®é¢˜



## Fragmentation

**å¤–éƒ¨ç¢ç‰‡åŒ–**ï¼šç©ºé—²å†…å­˜åŠ èµ·æ¥å¤Ÿç”¨ï¼Œä½†æ˜¯ä¸è¿ç»­

* sol
    * compaction (ç´§ç¼©)
        * Shuffle memory contents to place all free memory in one large block
        * Program needs to be relocatable at runtime
        * Performance overhead, timing to do this operation
    * paging



**å†…éƒ¨ç¢ç‰‡åŒ–**ï¼šåˆ†é…çš„æ¯”éœ€è¦çš„è¿˜å¤§ï¼ˆä¾‹å¦‚è¦500æœ‰502ï¼Œä¸ºäº†ä¸maintain2å­—èŠ‚çš„ä¿¡æ¯ï¼Œä¼šæŠŠæ•´ä¸ª502ä¸€èµ·åˆ†é…ï¼›å®é™…ä¸­éƒ½æ˜¯ä»¥é¡µä¸ºå•ä½è¿›è¡Œåˆ†é…çš„ï¼Œæ‰€ä»¥å³ä½¿åªæœ‰1Bä¹Ÿå¾—åˆ°1é¡µï¼‰

Sophisticated algorithms are designed to avoid fragmentation

* none of the first-/best-/worst-fit can be considered sophisticated

# Paging

ä½¿å†…å­˜åœ¨è™šæ‹Ÿå†…å­˜ä¸Šè¿ç»­ï¼ˆç‰©ç†ä¸ä¸€å®šè¿ç»­ï¼‰



é¡µå°ï¼šåˆ©äºå¤„ç†ç¢ç‰‡åŒ–ï¼Œä½†æ˜¯é¡µè¡¨çš„ç©ºé—´å ç”¨ä¼šå˜å¤§

é¡µå¤§ï¼šDMAéœ€è¦é¡µå¤§ï¼Œç”±äºå†…å­˜ç©ºé—´å¾ˆå¤§



==Pageä¸Frameï¼šPageæ˜¯Logicä¸Šçš„ï¼ŒFrameæ˜¯Physicalä¸Šçš„==

## Basic Methods

* Keep track of all free frames
* To run a program of size N pages, <u>need to find N free frames and load program</u>
* Set up a page table to translate logical to physical addresses
* Backing store likewise split into pages
* Still have Internal fragmentation



**Page Translation**

<img src="assets/image-20201123185055648.png" style="zoom:67%;" />



**Frame Table**: è¿½è¸ªç®¡ç†å“ªäº›frameï¼ˆç‰©ç†ï¼‰æ˜¯å·²åˆ†é…çš„

è·Ÿè¸ªä»¥ä¸‹ï¼š

* Which frame is free, and how many frames have been allocated
* One entry for each physical frame
* the allocated frame belongs to which process



**Free Frames**

å½“ç³»ç»Ÿè¿›ç¨‹éœ€è¦æ‰§è¡Œæ—¶ï¼Œå®ƒå°†æ£€æŸ¥è¯¥è¿›ç¨‹çš„å¤§å°ï¼ˆæŒ‰é¡µç®—ï¼‰ï¼Œnä¸ªpageè‡³å°‘å¯¹åº”nä¸ªframeã€‚å¦‚æœæœ‰nä¸ªframeï¼Œå°±å¯ä»¥åˆ†é…ç»™æ–°è¿›ç¨‹ã€‚è¿›ç¨‹çš„ç¬¬ä¸€ä¸ªpageè£…å…¥å·²åˆ†é…çš„frameï¼ŒframeNoè£…å…¥è¿™ä¸ªè¿›ç¨‹çš„PageTableã€‚

<img src="assets/image-20201123185717169.png" style="zoom:50%;" />

## Hardware Support

Simplest Case

* Page table is in a set of dedicated registers
    * Advantages: very efficient - access to register is fast
    * Disadvantages: the table size is very small, and the context switch need to save and restore these registers

Alternative Way

* ç»“æ„
    * é¡µè¡¨åœ¨Memé‡Œ
    * PTBR(page-table base register) æŒ‡å‘æœ¬è¿›ç¨‹çš„é¡µè¡¨
    * PTLR(page-table length register) å­˜ä½é¡µè¡¨çš„å¤§å°
* æ¯æ¬¡mem accesséœ€è¦ä¸¤æ¬¡accessï¼šä¸€æ¬¡è®¿é—®é¡µè¡¨ï¼Œä¸€æ¬¡è®¿é—®æ•°æ®
    * TLBç”¨äºåŠ é€ŸæŸ¥è¯¢



### TLB

ç”¨[associative memory](https://en.wikipedia.org/wiki/Content-addressable_memory)ï¼ˆå¹¶è¡ŒæŸ¥è¯¢ä¼˜åŒ–ï¼‰å®ç°

* support parallel search
* not addressed by â€œaddressesâ€, but **contents**
    * ç±»ä¼¼å“ˆå¸Œè¡¨å­—å…¸ï¼Œä¼ ç»™ä»–keyï¼Œè¿”å›value



ç”±äºTLBæ˜¯ç¡¬ä»¶ç»“æ„ï¼Œè¿›ç¨‹åˆ‡æ¢çš„æ—¶å€™éœ€è¦flush TLBã€‚ç°ä»£TLBä¸­æœ‰[ASID](https://stackoverflow.com/questions/52713940/purpose-of-address-spaced-identifiersasids)ä¼šå­˜å‚¨PIDï¼ŒæŸ¥è¯¢æ—¶å…ˆçœ‹çœ‹ASIDå¯¹ä¸å¯¹ï¼Œè¿™æ ·å°±çœå¾—æ¯æ¬¡éƒ½è¦context switch TLBä¸­çš„å†…å®¹

* åœ¨Armã€x86ç­‰ä¼ ç»Ÿæ¶æ„æ˜¯ç”±ç¡¬ä»¶flushçš„ï¼Œåœ¨MIPSä¸­æœ‰è½¯ä¸­æ–­æŠ›å‡ºå¼‚å¸¸ç”±è½¯ä»¶å®ç°ï¼ˆç¡¬ä»¶ç»“æ„ç®€å•ï¼‰



**EAT** (Effective Access Time)

**Ex**. ä¸»è¦æ˜¯è€ƒè™‘è®¿é—®PTå¯¼è‡´çš„é¢å¤–å†…å­˜è®¿é—®å¼€é”€

> Suppose that 10 nanoseconds to access memory.
> * If we find the desired page in TLB then a mapped-memory access take 10 ns
> * Otherwise we need two memory access so it is 20 ns: page table + memory access

EAT = 0.80 x 10 + 0.20 x 20 = 12 nanoseconds (implying 20% slowdown in access time

( = Data/Inst access time + 0.2\*PT access time = 10+0.2\*10 )



## Protecion of Page

* Each page table entry has a present (aka. valid) bit
    * è¡¨ç¤ºç‰©ç†å†…å­˜ä¸Šå­˜åœ¨ä¸è¿™ä¸ªpageå¯¹åº”çš„frame
* Each page table entry contains some protection bits
    * kernel/user, read/write, execution?, kernel-execution?
* å…¶ä»–protectionä½ï¼šNX, PXN (Privilege Exec Never)



## Page Sharing

ä¾‹å¦‚å¯¹äºlibcï¼Œé‡Œé¢æœ‰codeæ®µã€dataæ®µï¼Œå…¶ä¸­codeæ®µæ˜¯xä¸”å…±äº«çš„ï¼Œdataæ®µæ˜¯rwçš„ï¼Œä¸”dataæ®µåœ¨ä¸åŒè¿›ç¨‹ä¹‹é—´ä¸å¯å…±äº«ï¼ˆé€šè¿‡pageçš„éš”ç¦»å®ç°ï¼‰



* Paging allows to share memory between processes
    * e.g., one copy of code shared by all processes of the same program
        * text editors, compilers, browser...
        * è¦æ±‚æ˜¯ä¸èƒ½è‡ªæˆ‘ä¿®æ”¹çš„ä»£ç 
    * shared memory can be used for inter-process communication
    * shared libraries
* Reentrant code: non-self-modifying code: never changes between execution
* Each process can, of course, have its private code and data



double mappingçš„é—®é¢˜ï¼šP1çš„codeæ®µåœ¨P2æ˜¯rwçš„ï¼Œå±é™©



# PT Struct

## PT Hierarchy

**Multilevel Paging**

* èŠ‚çœç©ºé—´
    * å¦‚æœè®¾è®¡å¾—å½“ï¼Œä¸€çº§é¡µè¡¨å¯ä»¥å­˜åœ¨ä¸€ä¸ªé¡µé‡Œï¼Œå› æ­¤æ¯æ¬¡åªè¦è®¿é—®ä¸€ä¸ªé¡µå°±èƒ½è·å¾—ä¸€çº§çš„Frame Number



**Hashed PT**

ç”¨çš„æ˜¯é“¾è¡¨çš„é‚£ç§ï¼ˆå¦‚æœä¸æ˜¯çš„è¯é‚£ä¸ªä¸¤å€çš„è¦æ±‚ä¼šå¯¼è‡´é¡µè¡¨å¤ªå¤§ï¼‰



**Inverted PT**

ç”±Frame->Pageçš„ç´¢å¼•ï¼Œè¦æ±‚ç‰©ç†å†…å­˜æ¯”è¾ƒå°ï¼ˆå› ä¸ºè¦éå†æ•´ä¸ªé¡µè¡¨ï¼‰

## Swapping

* ä¸éœ€è¦æ‰€æœ‰çš„pageséƒ½æ‹¿å»swapï¼Œåªéœ€è¦éƒ¨åˆ†å³å¯ï¼ˆä»¥pageè€Œä¸æ˜¯processä¸ºç²’åº¦è¿›è¡Œswappingï¼‰
* å¯¹context switchçš„å½±å“è¾ƒå¤§
    * diskå¤ªæ…¢äº†
* mobile systemä¸€èˆ¬ä¸æ”¯æŒswappingï¼ˆflashå’Œmemä¹‹é—´çš„å¸¦å®½è¾ƒä½ï¼‰

# Example: The Intel 32 and 64-bit Architectures

## IA-32 Segmentation

æ®µé¡µ

* First partition of up to 8 K segments are private to process (kept in local descriptor table (LDT))
* Second partition of up to 8K segments shared among all processes (kept in global descriptor table (GDT))



==é€»è¾‘åœ°å€ï¼š{selector[15:0], offset[31:0]}==



Selector given to segmentation unit

* Which produces linear addresses

* <div align="left"><img src="assets/image-20201123203640724.png" style="zoom:70%;" /></div>

    * s-> segment number, g-> local/global, p->protection

* Segment selector is stored in the segment registers: CS, DS etc.

* GDTR, LDTR -> base address of the descriptor table

* descriptor: base, limit and other bits



==çº¿æ€§åœ°å€ï¼šsegment.descriptor(got by seg.selector)+logical.offset==

<img src="assets/image-20201123204057718.png" style="zoom:50%;" />

## IA-32 Paging

<img src="assets/image-20201123204355034.png" style="zoom:50%;" />

å®é™…å°±æ˜¯åŒå±‚é¡µè¡¨ï¼Œè¿™ä¸ª4M Pageå’ŒPageTableåœ¨æ•°æ®ä¸Šæ˜¯ä¸€æ ·çš„ï¼Œåªä¸è¿‡ç†è§£èµ·æ¥è¦æ ¹æ®ğŸ‘‡æ¥åŒºåˆ†

PageDirectoryä¸Šä¼šæœ‰ä¸ªPageSizeæ ‡å¿—ä½ï¼Œå¦‚æœè¢«ç½®ä½ï¼Œè¡¨ç¤ºPageå¤§å°ä¸º4MBï¼ŒPageDirectoryä¸Šçš„PTEä¼šç›´æ¥ç»•è¿‡å†…å±‚çš„PageTableæŒ‡å‘ä¸€ä¸ª4MBçš„é¡µ



### Page Addr Ext

* 32-bit address limits led Intel to create page address extension (PAE), allowing 32-bit apps access to more than 4GB of memory space
    * Paging went to a 3-level scheme
    * Top <u>two bits</u> refer to a **page directory pointer table**
    * Page-directory and page-table entries moved to 64-bits in size
    * Net effect is increasing address space to 36 bits â€“ 64GB of physical memory

<img src="assets/image-20201123210254481.png" style="zoom:67%;" />



## Linux for Pentium

* Linux uses only 6 segments
    * kernel code, kernel data, user code, user data
    * task-state segment (TSS), default LDT segment
* Linux only uses two of four possible modes
    * kernel: ring 0, user space: ring 3
* Uses a generic four-level paging for 32-bit and 64-bit systems
    * for two-level paging, middle and upper directories are omitted
    * older kernels have three-level generic paging



**Three-level Paging in Linux**

<img src="assets/image-20201123210012690.png" style="zoom:50%;" />

# Linux Paging

## 

linear addr = logical addr + base addr